---
description: start_python_backend
globs: backend/**/*
alwaysApply: false
---

- Typing is very important, so be sure to type any function arguments/outputs.
  - In Python, the lowercase types (e.g. ‘list’, ’dict’) should be used where available instead of importing from the typing package. Note that lowercase types do not need to be imported.
  - Use `SomeType | None` instead of `Optional[SomeType]`.
- Pathlib Paths should be used over the equivalent os functions.
- Use SQLAlchemy 2.x ORM syntax, not 1.x.
  - Some helpful context: my projects are typically structured such that models are in <project_name>.db.models, and you can create a session with `from <project_name>.db.session import get_session` (e.g. `from cdle.db.session`) and then `session = get_session()`.
- Use Pydantic 2.x syntax, not 1.x.
- Prefer Pydantic models over dataclasses when applicable.
- Prefer full imports for lowercase (non-class, usually) symbols, e.g. `import tenacity ... @tenacity.retry` or `import tqdm ... tqdm.tqdm()`, and `from` imports for uppercase constants and classes, e.g., `from blank.db.models import Chunk, CHUNK_SEPARATOR`.

- For writing standalone scripts:
    - We like progress bars! *Long-running, important* loops should use a tqdm progress bar with appropriate concise desc parameter set. When postfixes are necessary (e.g. if tracking the number of records skipped in some loop operation), define a `pbar` variable separately, and then update it and set the postfix within the loop manually.
    - To avoid confusion, always do "import tqdm" and then "tqdm.tqdm" for the progress bar instead of "from tqdm import tqdm". Repeat, use `import tqdm` and `tqdm.tqdm(...)` in code, NEVER `from tqdm import tqdm` and `tqdm(...)`.
- When writing Python scripts, we have a utility library called `rl`. Some notes on `rl` and the way we use it:
    - We have an enhanced version of click, the Python CLI library. The only difference in usage from the regular click is one does `import rl.utils.click as click` instead of `import click`.
    - When using logging in a program, use `rl`'s preconfigured logger: `from rl.utils import LOGGER`.
    - `rl` has (among others) the following IO functions, usable within `import rl.utils.io` (do not `from import`, use the absolute import):
        - `def get_data_path(*args) -> Path` — Generally, whenever a CLI script deals with input and output files/dirs, the default paths (which should typically be configurable via CLI options) are set on some subpath of the data path. E.g. `_DEFAULT_OUTPUT_DIR = rl.utils.io.get_data_path("raw_codes", "sf")`.
        - `def read_jsonl(filename: str | Path) -> Iterable[Any]` — yield an iterable of JSON-parsed items from a JSONL file, used as `for record in rl.utils.io.read_jsonl(...):` etc.
        - `def write_jsonl(filename: str | Path, records: Iterable[Any], overwrite=False) -> None` — write an iterable of records (either json-serializable records or Pydantic models) to the given path until exhaustion. Note that the filepath comes first.
        - `def download(url: str, dest: str | Path) -> None` — Downloads a given url to a file with a progress bar, so when doing pure downloads this is preferable.
- When creating click CLIs, obey the following conventions:
    - Unless otherwise instructed, prefer options, not arguments. Provide concise and descriptive help text for each option. Provide both a long (--foo) and short (-f) for all options unless doing so would lead to a conflict.
    - Default values for options should be stored as private global constants (`_ALL_CAPS`) at the top of the file and then referenced (`default=_DEFAULT_INPUT_PATH`) in the option decorator.
    - When declaring options that refer to file paths or directories, file paths should be suffixed with '_path', while directory paths should be suffixed with '_dir'. Path options should always be declared with `type=click.Path([any applicable exists/okay options], path_type=Path)` and the resulting function argument should therefore be typed as a pathlib `Path`.
